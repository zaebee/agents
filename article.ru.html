<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Сказание о Волшебной Пасеке</title>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&family=Patrick+Hand&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --honey-yellow: #f9c846;
            --dark-honey: #d4a017;
            --comb-brown: #5e3023;
            --bee-black: #2c1810;
            --highlight: #ff8c00;
        }

        body {
            font-family: 'Montserrat', sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #f5f1e8 0%, #e8d5b7 100%);
        }

        h1,
        h2,
        h3,
        h4 {
            font-family: 'Patrick Hand', cursive;
            color: var(--comb-brown);
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 3em;
        }

        h2 {
            border-bottom: 2px solid var(--dark-honey);
            padding-bottom: 10px;
            margin-top: 40px;
            font-size: 2.2em;
        }

        h3 {
            font-size: 1.8em;
            margin-top: 30px;
        }

        h4 {
            font-size: 1.4em;
            margin-top: 20px;
            color: var(--dark-honey);
        }

        .subtitle {
            text-align: center;
            margin-bottom: 30px;
            font-style: italic;
            color: #666;
            font-size: 1.2em;
        }

        .content-wrapper {
            background: rgba(255, 255, 255, 0.85);
            border-radius: 8px;
            padding: 25px 40px;
            margin: 20px 0;
            border: 1px solid var(--dark-honey);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .code-block-wrapper {
            position: relative;
            margin-top: 20px;
        }

        pre {
            background: #2c1810;
            color: #f5f1e8;
            padding: 20px;
            padding-top: 45px;
            /* space for the button */
            border-radius: 5px;
            overflow-x: auto;
            border: 1px solid var(--dark-honey);
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .copy-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: var(--dark-honey);
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s, background-color 0.2s;
            font-family: 'Montserrat', sans-serif;
        }

        .copy-button:hover {
            opacity: 1;
        }

        .copy-button.copied {
            background-color: #28a745;
            opacity: 1;
        }

        code {
            font-family: 'Courier New', Courier, monospace;
            background-color: rgba(94, 48, 35, 0.1);
            padding: 2px 5px;
            border-radius: 4px;
            color: var(--comb-brown);
        }

        pre code {
            background-color: transparent;
            padding: 0;
            color: #f5f1e8;
        }

        hr {
            border: 0;
            height: 1px;
            background-image: linear-gradient(to right, rgba(0, 0, 0, 0), rgba(94, 48, 35, 0.75), rgba(0, 0, 0, 0));
            margin: 60px 0;
        }

        .mermaid {
            background: white;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--dark-honey);
        }

        li {
            margin-bottom: 10px;
        }

        .genesis-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            font-family: 'Patrick Hand', cursive;
            color: var(--comb-brown);
            font-size: 1.5em;
        }

        .genesis-svg-wrapper {
            width: 300px;
            height: 300px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 8px;
            border: 1px solid var(--dark-honey);
        }

        .primitive {
            stroke: var(--comb-brown);
            stroke-width: 1;
            animation-duration: 4s;
            animation-timing-function: ease-in-out;
            animation-iteration-count: infinite;
        }

        .a-primitive {
            fill: #fff3cd;
            animation-name: converge-a;
        }

        .t-primitive {
            fill: #fff9e6;
            animation-name: converge-t;
        }

        .c-primitive {
            fill: #f1c40f;
            animation-name: converge-c;
        }

        .g-primitive {
            fill: #ffeb99;
            animation-name: converge-g;
        }

        .core-hexagon {
            fill: var(--honey-yellow);
            stroke: var(--dark-honey);
            stroke-width: 2;
            transform-origin: center;
            animation: glow 4s ease-in-out infinite;
            opacity: 0;
        }

        /* Keyframes for primitives converging */
        @keyframes converge-a {

            0%,
            100% {
                transform: translate(0, 0);
                opacity: 1;
            }

            40% {
                transform: translate(70px, 70px);
                opacity: 1;
            }

            60% {
                transform: translate(70px, 70px);
                opacity: 0;
            }
        }

        @keyframes converge-t {

            0%,
            100% {
                transform: translate(0, 0);
                opacity: 1;
            }

            40% {
                transform: translate(-70px, 70px);
                opacity: 1;
            }

            60% {
                transform: translate(-70px, 70px);
                opacity: 0;
            }
        }

        @keyframes converge-c {

            0%,
            100% {
                transform: translate(0, 0);
                opacity: 1;
            }

            40% {
                transform: translate(70px, -70px);
                opacity: 1;
            }

            60% {
                transform: translate(70px, -70px);
                opacity: 0;
            }
        }

        @keyframes converge-g {

            0%,
            100% {
                transform: translate(0, 0);
                opacity: 1;
            }

            40% {
                transform: translate(-70px, -70px);
                opacity: 1;
            }

            60% {
                transform: translate(-70px, -70px);
                opacity: 0;
            }
        }

        /* Keyframe for the core appearing and glowing */
        @keyframes glow {

            0%,
            50%,
            100% {
                opacity: 0;
                transform: scale(0.5);
            }

            70% {
                opacity: 1;
                transform: scale(1);
                filter: drop-shadow(0 0 6px var(--highlight));
            }

            90% {
                opacity: 1;
                transform: scale(1);
                filter: drop-shadow(0 0 6px var(--highlight));
            }
        }
    </style>
</head>

<body>
    <h1>Сказание о Волшебной Пасеке</h1>
    <div class="subtitle">Басня о Коде и Мёде</div>

    <div class="content-wrapper">
        <p>В некотором царстве, в некотором цифровом государстве, жила-была гильдия строителей. Но строили они не замки
            и мосты, а сложные, невидимые структуры из чистой логики. Это были архитекторы и разработчики программного
            обеспечения, и их величайшей задачей было создание систем, которые могли бы расти и адаптироваться, не
            рассыпаясь в хаос.</p>
        <p>Они трудились день и ночь, используя всевозможные чертежи и заклинания, но их творения часто превращались в
            запутанные клубки — хрупкие и трудные для изменения. Они мечтали о способе создавать программное
            обеспечение, которое было бы таким же устойчивым, организованным и полным жизни, как шумный пчелиный улей.
        </p>
        <p>Однажды мудрая старая архитектор, известная лишь как Пасечница, собрала молодых строителей. «Вы стремитесь
            создавать великие вещи, — сказала она голосом, тёплым, как летний мёд. — Но вы строите из камня и железа,
            тогда как должны строить из самой жизни. Посмотрите на пчёл. Их ульи — шедевры дизайна, построенные на века.
            Давайте же узнаем их секреты».</p>
        <p>Так начинается наше сказание. История не только о коде, но и о вечных законах природы, которые могут помочь
            нам создавать лучшее и более красивое программное обеспечение. Мы отправимся в самое сердце Гексагонального
            Улья, раскроем его секретный генетический код и научимся растить наших собственных «рабочих пчёл», которые
            будут верой и правдой служить нашему цифровому королевству.</p>
    </div>

    <hr>

    <div class="content-wrapper">
        <h2>Сердце Улья: Защищённое Королевство</h2>
        <p>«Первый секрет пчёл, — начала Пасечница, — это их дом. Улей — это крепость, идеальный шестиугольник. В самом
            его центре лежит самое драгоценное сокровище: мёд и маточный расплод. Это <strong>Ядро Домена</strong>, где
            решается жизнь и будущее улья. Оно содержит чистую, неизменную бизнес-логику вашего приложения».</p>
        <p>«Вокруг этого ядра пчёлы строят защитные слои из восковых сот. Это <strong>Адаптеры</strong>. Они —
            единственная связь улья с внешним миром. Некоторые адаптеры, <strong>Первичные Адаптеры</strong>, подобны
            входу в улей и позволяют дружественным пчёлам (например, пользователям или другим приложениям) входить и
            делать запросы. Другие, <strong>Вторичные Адаптеры</strong>, подобны пчёлам-сборщицам, которые вылетают,
            чтобы собрать нектар с цветов (внешних баз данных, API или сервисов)».</p>
        <p>«Волшебство этой конструкции, — прошептала она, — в том, что вы можете изменить сад, цветы или даже форму
            входа, но драгоценное медовое ядро останется нетронутым и в безопасности. Таков путь <strong>Гексагонального
                Улья</strong>».</p>
    </div>

    <hr>

    <div class="content-wrapper">
        <h2>Секретный Генетический Код: Четыре Примитива Жизни</h2>
        <p>«Но как создаются сами пчёлы?» — спросил молодой строитель.</p>
        <p>Пасечница улыбнулась. «Ага, это самый глубокий секрет из всех. Каждое живое существо в улье создано из
            секретного, четырёхчастного генетического кода. Этот код — источник истины, сама суть жизни. Мы называем его
            <strong>ATCG</strong>».
        </p>

        <h3>A — это Агрегат (Aggregate)</h3>
        <p>«<strong>Агрегат</strong> подобен жизненно важному органу пчелы — её сердцу или крыльям. Это совокупность
            крошечных частей, которые работают вместе как единое целое. Вы не говорите части крыла взмахнуть; вы
            говорите пчеле лететь! Агрегат — хозяин своего маленького мира, следящий за соблюдением всех своих
            внутренних правил. Это фундаментальная единица согласованности».</p>

        <h3>T — это Трансформация (Transformation)</h3>
        <p>«<strong>Трансформация</strong> подобна волшебному ферменту. Это чистый процесс без состояния, который
            помогает пчеле выполнять свою работу. Представьте фермент, который превращает нектар в мёд. Сам фермент не
            меняется, он просто выполняет свою одну, идеальную задачу. Трансформации содержат бизнес-логику, которая не
            принадлежит ни одному конкретному органу».</p>

        <h3>C — это Коннектор (Connector)</h3>
        <p>«<strong>Коннектор</strong> — это органы чувств пчелы: её антенны, которые чуют запах цветов, или её глаза,
            которые видят солнце. Это мост между внутренним миром пчелы и садом снаружи. Коннекторы — это переводчики,
            превращающие язык внешнего мира (например, HTTP-запросы или запросы к базе данных) в сигналы, понятные
            органам пчелы».</p>

        <h3>G — это Событие Генезиса (Genesis Event)</h3>
        <p>«<strong>Событие Генезиса</strong> — это знаменитый 'виляющий танец' пчелы. Это сообщение, транслируемое
            всему улью, о том, что произошло нечто важное: 'Я нашла поле с восхитительными цветами!' или 'Заказ был
            размещён!'. Это непреложный факт, частичка истории, на которую могут реагировать другие пчёлы, позволяя улью
            работать сообща, не будучи жёстко связанными».</p>

        <p style="text-align: center; font-style: italic; margin-top: 30px;">Эти четыре примитива — буквы нашего
            генетического алфавита. Когда они соединяются, рождается новый компонент. Наблюдайте за их генезисом:</p>
        <div class="genesis-container">
            <div class="genesis-svg-wrapper">
                <svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="30" cy="30" r="15" class="primitive a-primitive" />
                    <circle cx="170" cy="30" r="15" class="primitive t-primitive" />
                    <circle cx="30" cy="170" r="15" class="primitive c-primitive" />
                    <circle cx="170" cy="170" r="15" class="primitive g-primitive" />
                    <path d="M 100,25 L 175,62.5 L 175,137.5 L 100,175 L 25,137.5 L 25,62.5 Z" class="core-hexagon" />
                </svg>
            </div>
        </div>

        <h2>Маточное Молочко (Royal Jelly Framework)</h2>
        <p>«Наконец, — сказала Пасечница, — каждая Пчелиная Королева, мать целого домена, рождается из одного и того же
            волшебного вещества: <strong>Маточного Молочка</strong>».</p>
        <p>«В нашем мире это крошечный, мощный внутренний фреймворк. Он сам не выполняет никакой бизнес-логики, но
            предоставляет необходимые питательные вещества — базовые классы, интерфейсы, саму суть того, чтобы быть
            <code>Агрегатом</code> или <code>Событием Генезиса</code>. Каждое ядро домена в вашем королевстве построено
            на этой общей, священной основе, гарантируя, что все они говорят на одном языке и следуют одним и тем же
            божественным законам».
        </p>
    </div>

    <hr>

    <div class="content-wrapper">
        <h2>Карта Пасеки: Портрет Улья</h2>
        <p>«Чтобы по-настоящему понять, — сказала Пасечница, доставая старую, зачарованную карту, — вы должны увидеть
            улей целиком».</p>
        <p>На карте была изображена живая, дышащая система. Наверху был <strong>Сад</strong>, мир за пределами улья с
            его пользователями, базами данных и другими системами. Ниже лежал сам <strong>Великий Гексагональный
                Улей</strong>. Внешний слой состоял из <strong>Коннекторов (C)</strong>, органов чувств, охранявших
            улей. А в самом центре находилась <strong>Палата Королевы</strong>, ядро домена, где обитали жизненно важные
            <strong>Агрегаты (A)</strong> и <strong>Трансформации (T)</strong>, и где рождались <strong>События Генезиса
                (G)</strong>.
        </p>
        <p>«Смотрите, — сказала она. — Полная картина нашей архитектуры. Система, спроектированная самой природой».</p>
        <div class="mermaid">
            graph TD
            subgraph Сад [Мир за пределами Улья]
            direction LR
            User["🧑‍🌾 Пользователь <br />(Веб-браузер)"]
            CLI["💻 Ветер <br />(CLI-инструмент)"]
            ExternalAPI["🌐 Другие Ульи <br />(Внешние API)"]
            Database["🗃️ Река Памяти <br />(База данных)"]
            end

            subgraph Улей [🏰 Великий Гексагональный Улей]
            direction TB

            subgraph Коннекторы [C: Органы чувств Улья]
            direction LR
            RestConnector["🔌 REST API Коннектор"]
            CliConnector["🔌 CLI Коннектор"]
            DbConnector["🗂️ Коннектор БД"]
            ApiClientConnector["🌍 API-клиент Коннектор"]
            end

            subgraph ЯдроДомена ["👑 Палата Королевы (Ядро Домена)"]
            direction TB

            subgraph Агрегаты [A: Органы]
            OrderAggregate["Пчела Заказа"]
            InventoryAggregate["Пчела Инвентаря"]
            end

            subgraph Трансформации [T: Ферменты]
            PricingTransformation["Логика создания мёда <br />(Калькулятор цен)"]
            end

            GenesisEvent["G: Виляющий Танец <br />(События Генезиса)"]

            OrderAggregate -- производит --> GenesisEvent
            InventoryAggregate -- производит --> GenesisEvent
            PricingTransformation -- используется --> OrderAggregate
            end
            end

            User --> RestConnector
            CLI --> CliConnector
            RestConnector --> OrderAggregate
            CliConnector --> InventoryAggregate
            OrderAggregate -- "сохраняет состояние через" --> DbConnector
            InventoryAggregate -- "получает остатки через" --> ApiClientConnector
            DbConnector --> Database
            ApiClientConnector --> ExternalAPI

            classDef external fill:#6B8E23,stroke:#333,stroke-width:2px,color:white
            classDef connector fill:#f1c40f,stroke:#333,stroke-width:2px,color:black
            classDef domain fill:#f9c846,stroke:#d4a017,stroke-width:4px,color:black
            classDef aggregate fill:#fff3cd,stroke:#d4a017,stroke-width:2px,color:black
            classDef transformation fill:#fff9e6,stroke:#d4a017,stroke-width:2px,color:black
            classDef event fill:#ffeb99,stroke:#d4a017,stroke-width:2px,stroke-dasharray: 5 5,color:black

            class User,CLI,ExternalAPI,Database external;
            class RestConnector,CliConnector,DbConnector,ApiClientConnector connector;
            class ЯдроДомена domain;
            class OrderAggregate,InventoryAggregate aggregate;
            class PricingTransformation transformation;
            class GenesisEvent event;

            style Сад fill:none,stroke:none
            style Улей fill:none,stroke:green,stroke-width:3px,stroke-dasharray: 10 10
        </div>
    </div>

    <hr>

    <div class="content-wrapper">
        <h2>Метаморфоза: Рождение Рабочей Пчелы</h2>
        <p>«Но как появляется на свет новая пчела — новая функция?» — спросил молодой строитель с любопытством в глазах.
        </p>
        <p>Пасечница улыбнулась. «Новую пчелу не просто строят. Она рождается. Она проходит метаморфозу, священный путь
            роста».</p>
        <p>Она объяснила, что каждая новая функция, каждая новая рабочая пчела, проходит один и тот же четырёхэтапный
            жизненный цикл:</p>
        <ol>
            <li><strong>Яйцо (Инициализация):</strong> Создаётся новая, пустая ячейка соты. Это начальная структура
                файлов, каркас для нашей новой пчелы. В ней нет ничего, кроме обещания.</li>
            <li><strong>Личинка (Разработка):</strong> Яйцо вылупляется! Личинку кормят Маточным Молочком (основным
                фреймворком) и пчелиным хлебом (бизнес-логикой). Здесь пишется код, создаются тесты, и пчела начинает
                обретать форму, а её код ATCG определяет её предназначение.</li>
            <li><strong>Куколка (Трансформация):</strong> Личинка плетёт кокон. Это этап сборки и контейнеризации. Код
                компилируется, зависимости фиксируются, и он упаковывается в развёртываемую единицу — образ Docker,
                безопасный и готовый к миру.</li>
            <li><strong>Взрослая особь (Развёртывание):</strong> Пчела появляется, полностью сформированная! Её
                выпускают в улей для выполнения своих обязанностей. Функция развёртывается в производственную среду,
                становясь живой, дышащей частью системы.</li>
        </ol>
        <p>«Этот жизненный цикл гарантирует, что каждая пчела, независимо от её функции, рождается сильной,
            протестированной и готовой содействовать процветанию улья», — заключила Пасечница.</p>
        <p>Вот жизненный цикл в виде простой диаграммы:</p>
        <div class="mermaid">
            stateDiagram-v2
            direction LR
            [*] --> Яйцо: Отложить яйцо
            Яйцо: Начальный каркас
            Яйцо --> Личинка: Вылупление
            Личинка: Разработка функции и тестов
            Личинка --> Куколка: Плести кокон
            Куколка: Сборка и контейнеризация
            Куколка --> Взрослая_особь: Появление
            Взрослая_особь: Развёртывание в прод
            Взрослая_особь --> [*]
        </div>
    </div>

    <hr>

    <div class="content-wrapper">
        <h2>Мораль Сей Басни</h2>
        <p>И так строители узнали секреты волшебной пасеки. Они поняли, что, обращаясь к природе, они могут создавать
            программное обеспечение, которое является не жёсткой, безжизненной машиной, а живой, адаптируемой
            экосистемой.</p>
        <p>Гексагональный Улей учит нас защищать нашу основную логику. Генетический код ATCG даёт нам общий язык для
            строительства. А жизненный цикл пчелы даёт нам предсказуемый путь для роста. Применяя эти паттерны, мы тоже
            можем строить цифровые королевства, которые будут устойчивыми, поддерживаемыми и по-настоящему полными
            жизни. Ведь в конце концов, лучший код не просто пишется; он выращивается.</p>
    </div>

    <hr>

    <div class="content-wrapper">
        <h2>Для Любознательных Умов: Технический Гримуар Пасечницы</h2>
        <p><em>Этот раздел отходит от нашей сказки, чтобы представить более технический взгляд на обсуждаемые нами
                паттерны.</em></p>

        <h3>Примитивы ATCG в псевдокоде</h3>
        <p>Вот концептуальный взгляд на то, как могут быть реализованы наши примитивы. Для ясности мы будем использовать
            синтаксис, подобный TypeScript.</p>

        <h4>A: Агрегат</h4>
        <p><code>Агрегат</code> инкапсулирует состояние и обеспечивает соблюдение собственных правил (инвариантов).</p>
        <div class="code-block-wrapper">
            <button class="copy-button">Копировать</button>
            <pre><code class="language-typescript">// Состояние нашего Заказа
interface OrderState {
  id: string;
  items: string[];
  status: "placed" | "shipped" | "cancelled";
}

class OrderAggregate {
  private state: OrderState;

  constructor(initialState: OrderState) {
    this.state = initialState;
  }

  // Публичный обработчик команд: единственный способ изменить агрегат
  public shipOrder(command: { shippingId: string }): GenesisEvent {
    if (this.state.status !== "placed") {
      throw new Error("Нельзя отправить заказ, который не был размещён.");
    }

    // Состояние изменяется путём применения события
    const event = new OrderShippedEvent({
      orderId: this.state.id,
      shippingId: command.shippingId,
      timestamp: new Date()
    });

    this.apply(event);

    return event;
  }

  // Внутреннее изменение состояния
  private apply(event: OrderShippedEvent): void {
    this.state.status = "shipped";
  }
}</code></pre>
        </div>

        <h4>C: Коннектор</h4>
        <p><code>Коннектор</code> преобразует внешний ввод в команды домена.</p>
        <div class="code-block-wrapper">
            <button class="copy-button">Копировать</button>
            <pre><code class="language-typescript">// Управляющий коннектор для REST API
class RestConnector {
  private orderService: OrderService; // Сервис, который находит и использует агрегаты

  public startServer(): void {
    // Псевдокод для веб-сервера
    WebApp.post("/orders/:id/ship", (req, res) => {
      try {
        const orderId = req.params.id;
        const shippingId = req.body.shippingId;

        // Задача коннектора — преобразовать HTTP в команду домена
        this.orderService.ship(orderId, shippingId);

        res.status(202).send({ message: "Заказ отправляется." });
      } catch (error) {
        res.status(400).send({ error: error.message });
      }
    });
  }
}</code></pre>
        </div>

        <h3>"Протокол Пыльцы": Заметка о междоульевом общении</h3>
        <p><strong>Протокол Пыльцы</strong> — это простая и мощная идея: так же, как цветы имеют предсказуемую
            структуру, понятную пчёлам, наши <code>События Генезиса</code> должны иметь предсказуемую структуру, чтобы
            другие сервисы (Ульи) могли их понимать.</p>
        <p>Событие, совместимое с Протоколом Пыльцы, всегда должно содержать:</p>
        <ul>
            <li><code>eventId</code>: Уникальный идентификатор для этого конкретного экземпляра события.</li>
            <li><code>eventType</code>: Чёткое имя в прошедшем времени (например, <code>OrderShipped</code>).</li>
            <li><code>eventVersion</code>: Номер версии (<code>1.0</code>, <code>2.1</code>) для управления эволюцией
                схемы.</li>
            <li><code>timestamp</code>: Время, когда произошло событие.</li>
            <li><code>aggregateId</code>: Идентификатор агрегата, который произвёл событие.</li>
            <li><code>payload</code>: Данные, специфичные для этого события.</li>
        </ul>
        <p>Применяя этот простой контракт, мы создаём здоровую экосистему, где новые сервисы могут легко потреблять
            события от существующих, не создавая жёсткой связи.</p>
        <p>И последняя мысль по этой метафоре: если Протокол Пыльцы определяет <em>гены</em> (структуру события), то
            сырые, сериализованные данные, которые передаются по сети — строка JSON, байты Protobuf — это и есть сама
            <em>генетическая последовательность</em>. Это <code>tataaaaataaaataaaaaa...</code> нашей системы, физическое
            выражение логического гена.
        </p>

        <h3>Диаграмма последовательности: От запроса до виляющего танца</h3>
        <p>Эта диаграмма показывает полный поток: запрос пользователя поступает через <code>Коннектор</code>,
            обрабатывается <code>Агрегатом</code>, который производит <code>Событие Генезиса</code>, публикуемое для
            потребления другими частями системы.</p>
        <div class="mermaid">
            sequenceDiagram
            participant User as 🧑‍🌾 Пользователь
            participant REST_C as C: REST Коннектор
            participant Order_A as A: Агрегат Заказа
            participant Events_G as G: Шина Событий

            User->>+REST_C: POST /orders/123/ship
            REST_C->>+Order_A: handle_command(shipOrder)
            Order_A-->>Order_A: Применение бизнес-правил
            Order_A->>Order_A: apply(OrderShippedEvent)
            Order_A-->>-REST_C: return OrderShippedEvent
            REST_C-->>-User: 202 Accepted

            REST_C->>+Events_G: publish(OrderShippedEvent)
            Note over Events_G: Другие Ульи (напр., Доставка) слушают этот "виляющий танец"
            Events_G-->>-REST_C:
        </div>

        <h3>Великое Видение Пасечницы: Самосоздающиеся Системы</h3>
        <p>Последний, самый глубокий секрет улья таков: если архитектура достаточно чиста, система может начать строить
            себя сама. Сопоставление "Метаморфоза -> ATCG" — это не просто метафора для ручного процесса; это план для
            автоматизации.</p>
        <p>Представьте себе разработчика, который хочет создать новую «пчелу» (функцию). Вместо того чтобы писать
            шаблонный код, он просто создаёт декларативное определение, возможно, в файле YAML, указывая требуемые
            примитивы ATCG:</p>
        <div class="code-block-wrapper">
            <button class="copy-button">Копировать</button>
            <pre><code class="language-yaml"># Декларативное определение для новой функции "ShippingNotification"
kind: WorkerBee
name: ShippingNotifier
description: "Пчела, которая отправляет уведомление при отгрузке заказа."

listens_to: # События Генезиса, на которые реагирует эта пчела
  - eventType: OrderShipped
    eventVersion: 1.0

produces: # Новые События Генезиса, которые может создавать эта пчела
  - eventType: NotificationSent
    eventVersion: 1.0

# Коннекторы, необходимые для взаимодействия с внешним миром
connectors:
  - name: email_service
    type: driven # Эта пчела управляет внешним сервисом
    port: SmtpPort</code></pre>
        </div>
        <p>Автоматизированная система <strong>«Пчелиная Королева»</strong> — сложный оператор CI/CD — читает это
            определение и организует всю Метаморфозу:</p>
        <ul>
            <li><strong>Яйцо:</strong> Она получает YAML и генерирует начальный каркас проекта, создавая все необходимые
                файлы из шаблонов.</li>
            <li><strong>Личинка:</strong> Она берёт основную бизнес-логику, написанную разработчиком (единственная
                часть, требующая человеческого творчества), и внедряет её в сгенерированный код. Затем она запускает
                набор автоматизированных тестов для нового компонента.</li>
            <li><strong>Куколка:</strong> После успешного тестирования она упаковывает компонент в защищённый, готовый к
                развёртыванию контейнер.</li>
            <li><strong>Взрослая особь:</strong> Она развёртывает этот новый контейнер в производственную среду, где он
                оживает и начинает слушать указанные события.</li>
        </ul>
        <p>Это конечная цель: архитектура, настолько хорошо определённая, что она становится живой фабрикой для своих
            собственных компонентов. Это слияние Domain-Driven Design, GitOps и Model-Driven Development, создающее
            систему, которая не просто построена, а по-настоящему <em>выращена</em>.</p>

        <h3>Продвинутое Пчеловодство: Сбор Ресурсов, Времена Года и Защита</h3>
        <p>По мере взросления улей разрабатывает более сложные стратегии взаимодействия с миром, управления собственным
            ростом и защиты.</p>

        <h4>Паттерны Сбора Ресурсов (Паттерны Устойчивости и Кэширования)</h4>
        <p>Выживание улья зависит от того, насколько эффективно он собирает ресурсы из внешнего мира (внешних сервисов).
        </p>
        <ul>
            <li><strong>Паттерн "Пчела-разведчица" (Автоматический выключатель):</strong> Прежде чем отправить сотни
                сборщиц на новое поле цветов (внешний API), улей сначала отправляет нескольких разведчиц. Если
                разведчицы сталкиваются с опасностью или не находят нектара (API не работает или медленный), они
                возвращаются и сигнализируют, что не стоит тратить ресурсы на это поле в течение некоторого времени. Это
                предотвращает каскадный сбой во всем улье из-за неработающего внешнего сервиса.</li>
            <li><strong>Паттерн "Нектарный Запас" (Кэширование):</strong> Для часто посещаемых цветов пчёлы не всегда
                летят обратно в главный улей. Они могут хранить нектар в небольших, более близких сотах для быстрого
                доступа. Точно так же наши приложения должны кэшировать часто запрашиваемые данные из внешних сервисов
                для уменьшения задержек и нагрузки.</li>
        </ul>

        <h4>Времена Года в Улье (Жизненный цикл системы)</h4>
        <p>Программная система, как и улей, имеет времена года, которые диктуют её основную деятельность.</p>
        <ul>
            <li><strong>Весна (Рост):</strong> Время бурного роста. Королева откладывает много яиц, и постоянно
                рождаются новые пчёлы (функции). Основное внимание уделяется быстрому развитию и расширению.</li>
            <li><strong>Лето (Зрелость):</strong> Улей находится на пике производительности. Фокус смещается со
                строительства новых сот на производство как можно большего количества мёда (бизнес-ценности). Система
                стабильна, и работа сосредоточена на оптимизации и производительности.</li>
            <li><strong>Осень (Рефакторинг и Устаревание):</strong> Улей готовится к зиме. Старые, неиспользуемые соты
                очищаются, а ресурсы консолидируются. Это время для погашения технического долга, рефакторинга сложных
                областей и вывода из эксплуатации старых функций, которые больше не приносят пользы.</li>
            <li><strong>Зима (Поддержка):</strong> Период затишья. Активность улья замедляется, сосредотачиваясь только
                на выживании и необходимом обслуживании. Для программного обеспечения это может быть период заморозки
                кода, когда работа ограничивается критическими исправлениями безопасности и поддержанием стабильности
                системы.</li>
        </ul>

        <h4>Вредители и Хищники (Паттерны Безопасности)</h4>
        <p>Богатый улей — это цель. Он должен защищаться от угроз.</p>
        <ul>
            <li><strong>Пчёлы-охранницы (Аутентификация и Авторизация):</strong> Не каждый может войти в улей.
                Пчёлы-охранницы у входа проверяют каждого посетителя, проверяя его уникальный запах, чтобы убедиться,
                что он свой. Это наш слой аутентификации и авторизации, гарантирующий, что только действительные
                пользователи и сервисы могут получить доступ к системе.</li>
            <li><strong>Прополис (Валидация и Санитизация Входных Данных):</strong> Пчёлы используют липкое,
                антимикробное вещество под названием прополис, чтобы заделать каждую щель и трещину, предотвращая
                проникновение болезней. Это наша строгая валидация входных данных. Мы должны рассматривать все данные из
                внешнего мира как потенциально вредные, очищая и проверяя их, прежде чем они достигнут нашего ядра
                домена.</li>
        </ul>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const allCodeBlocks = document.querySelectorAll('.code-block-wrapper');

            allCodeBlocks.forEach(wrapper => {
                const button = wrapper.querySelector('.copy-button');
                const pre = wrapper.querySelector('pre');
                if (!button || !pre) return;

                button.textContent = 'Копировать';
                const code = pre.querySelector('code');
                const textToCopy = code.innerText;

                button.addEventListener('click', () => {
                    navigator.clipboard.writeText(textToCopy).then(() => {
                        button.textContent = 'Скопировано!';
                        button.classList.add('copied');

                        setTimeout(() => {
                            button.textContent = 'Копировать';
                            button.classList.remove('copied');
                        }, 2000);
                    }).catch(err => {
                        console.error('Не удалось скопировать текст: ', err);
                        button.textContent = 'Ошибка';
                    });
                });
            });
        });
    </script>
</body>

</html>