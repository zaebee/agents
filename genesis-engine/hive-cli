#!/usr/bin/env python3

import argparse
import os
import pathlib
import string
import subprocess
import sys

# --- Configuration ---
HIVE_ROOT = "hive/components"
TEMPLATE_ROOT = "genesis-engine/templates"
SCOUT_BEE_SCRIPT = "hive/components/scout-bee/main.py"

def show_usage():
    """Prints a more detailed usage message."""
    script_name = os.path.basename(__file__)
    print("The Genesis Engine - The 'Connector' to the Hive.")
    print("This tool scaffolds new components and interacts with the hive.\n")
    print("Usage:")
    print(f"  ./{script_name} <command> [options]\n")
    print("Commands:")
    print("  hatch   Scaffold a new component from a template.")
    print("  scout   Use the Scout Bee to explore an OpenAPI specification.\n")
    print("Examples:")
    print(f"  ./{script_name} hatch command create-new-order")
    print(f"  ./{script_name} scout http://crm.zae.life/openapi.json")
    print(f"\nRun './{script_name} <command> --help' for more information on a specific command.")


def snake_to_pascal(snake_case_string: str) -> str:
    """Converts snake_case or kebab-case to PascalCase."""
    return snake_case_string.replace("-", "_").replace("_", " ").title().replace(" ", "")

def hatch_component(codon_type: str, component_name: str):
    """
    Generates a new component from templates.
    """
    print(f"Hatching new '{codon_type}' codon named '{component_name}'...")

    component_dir_name = component_name.replace("-", "_")
    component_path = pathlib.Path(HIVE_ROOT) / component_dir_name
    if component_path.exists():
        print(f"Error: Component '{component_name}' already exists at {component_path}.", file=sys.stderr)
        exit(1)

    template_dir = pathlib.Path(TEMPLATE_ROOT) / codon_type
    if not template_dir.is_dir():
        print(f"Error: No templates found for codon type '{codon_type}' at {template_dir}.", file=sys.stderr)
        print("This functionality has not been implemented yet.", file=sys.stderr)
        exit(1)

    component_path.mkdir(parents=True)
    print(f"Created directory: {component_path}")

    class_name = snake_to_pascal(component_name)
    substitutions = {
        "ComponentName": component_name,
        "ClassName": class_name,
    }

    for template_file in template_dir.glob("*.tpl"):
        with open(template_file, "r") as f:
            template_content = f.read()

        template = string.Template(template_content)
        rendered_content = template.safe_substitute(substitutions)

        output_filename = template_file.stem
        output_path = component_path / output_filename

        with open(output_path, "w") as f:
            f.write(rendered_content)

        print(f"  -> Generated {output_path}")

    (component_path / "__init__.py").touch()
    print(f"  -> Generated {component_path / '__init__.py'}")

    print("\nSuccess! New codon hatched.")
    print("Next steps: Implement the business logic and 'spin cocoon' to add tests.")

def scout_command(url: str):
    """
    Executes the Scout Bee script for a given URL.
    """
    print(f"Dispatching Scout Bee to: {url}...")

    if not pathlib.Path(SCOUT_BEE_SCRIPT).exists():
        print(f"Error: Scout Bee script not found at {SCOUT_BEE_SCRIPT}", file=sys.stderr)
        exit(1)

    try:
        # We use sys.executable to ensure we're using the same python interpreter
        result = subprocess.run(
            [sys.executable, SCOUT_BEE_SCRIPT, url],
            capture_output=True,
            text=True,
            check=True  # This will raise CalledProcessError if the script returns a non-zero exit code
        )
        print(result.stdout)
    except subprocess.CalledProcessError as e:
        print("Error: The Scout Bee returned an error.", file=sys.stderr)
        print("\n--- Scout Bee STDOUT ---", file=sys.stderr)
        print(e.stdout, file=sys.stderr)
        print("\n--- Scout Bee STDERR ---", file=sys.stderr)
        print(e.stderr, file=sys.stderr)
        exit(1)
    except FileNotFoundError:
        print(f"Error: Could not find '{sys.executable}'. Make sure python is in your PATH.", file=sys.stderr)
        exit(1)


def main():
    """Main entry point for the CLI."""
    # Custom help handling
    # The main parser is only for the help message, subparsers handle the real commands
    if len(sys.argv) == 1 or '-h' in sys.argv or '--help' in sys.argv:
        # If it's a command-specific help, let the subparser handle it, unless it's the root help.
        if len(sys.argv) == 1 or (len(sys.argv) > 1 and sys.argv[1] in ['-h', '--help']):
             show_usage()
             exit(0)

    parser = argparse.ArgumentParser(
        description="The Genesis Engine: a CLI for managing the Hive codebase.",
        add_help=False, # We show custom usage.
    )

    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # --- Hatch Command ---
    parser_hatch = subparsers.add_parser("hatch", help="Scaffold a new component from a template.")
    parser_hatch.add_argument(
        "codon_type",
        choices=["command", "query", "event"],
        help="The type of codon to scaffold.",
    )
    parser_hatch.add_argument("component_name", help="The name of the new component (e.g., 'create-order').")

    # --- Scout Command ---
    parser_scout = subparsers.add_parser("scout", help="Use the Scout Bee to explore an OpenAPI specification.")
    parser_scout.add_argument("url", help="The URL of the OpenAPI specification to scout.")

    # Parse args, but handle case where no command is given
    if len(sys.argv) < 2 or sys.argv[1] not in ['hatch', 'scout']:
        show_usage()
        exit(1)

    args = parser.parse_args()

    if args.command == "hatch":
        hatch_component(args.codon_type, args.component_name)
    elif args.command == "scout":
        scout_command(args.url)
    else:
        # This case should not be reachable due to the check above
        show_usage()
        exit(1)

if __name__ == "__main__":
    main()
